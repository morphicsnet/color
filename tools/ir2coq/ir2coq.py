#!/usr/bin/env python3
import argparse
import json
import re
from pathlib import Path
from datetime import datetime, timezone

try:
    from jsonschema import Draft202012Validator
except Exception:
    Draft202012Validator = None

try:
    from rich.console import Console
    console = Console()
except Exception:
    console = None

def log(msg: str):
    if console:
        console.log(msg)
    else:
        print(msg)

def load_schema(schema_path: Path):
    with open(schema_path, "r", encoding="utf-8") as f:
        return json.load(f)

def validate_ir(schema, ir_obj):
    if Draft202012Validator is None:
        log("[warn] jsonschema unavailable; skipping validation")
        return True, []
    v = Draft202012Validator(schema)
    errs = sorted(v.iter_errors(ir_obj), key=lambda e: list(e.path))
    if errs:
        lines = []
        for e in errs[:50]:
            loc = "$." + ".".join(str(p) for p in e.path)
            lines.append(f"{loc}: {e.message}")
        return False, lines
    return True, []

def load_ir(path: Path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def sanitize_module_segment(s: str) -> str:
    # Coq module segment: PascalCase, start with uppercase ASCII
    s = re.sub(r"[^A-Za-z0-9]+", " ", s)
    parts = [p for p in s.split() if p]
    if not parts:
        return "Doc"
    seg = "".join(p.capitalize() for p in parts)
    if not re.match(r"^[A-Z]", seg):
        seg = "M" + seg
    return seg[:64]

def sanitize_ident(s: str) -> str:
    # Coq ident: [a-zA-Z_][a-zA-Z0-9_']*
    s = s.strip()
    if not s:
        s = "x"
    s = re.sub(r"[^A-Za-z0-9_']+", "_", s)
    if not re.match(r"^[A-Za-z_]", s):
        s = "x_" + s
    return s[:64]

def mk_unique(base: str, taken: set) -> str:
    if base not in taken:
        taken.add(base)
        return base
    i = 2
    while True:
        cand = f"{base}_{i}"
        if cand not in taken:
            taken.add(cand)
            return cand
        i += 1

def choose_stmt_ident(stmt: dict, taken: set) -> str:
    # Prefer coq_mapping.ident if present
    cm = stmt.get("coq_mapping") or {}
    ident_pref = cm.get("ident")
    if not ident_pref:
        # derive from id then label/kind fallback
        ident_pref = stmt.get("id") or stmt.get("label") or (stmt.get("kind") or "s")
    return mk_unique(sanitize_ident(ident_pref), taken)

def stmt_kind_to_construct(kind: str) -> str:
    # Map IR kinds to Coq constructs we will emit
    k = (kind or "").lower()
    if k in ("axiom", "assumption"):
        return "Axiom"
    if k in ("lemma", "theorem", "proposition", "corollary"):
        return "Theorem"
    if k in ("definition",):
        return "Definition"
    if k in ("example",):
        # treat Example as Parameter Prop, non-binding
        return "Parameter"
    return "Axiom"

HEADER = """(*
 Auto-generated by tools/ir2coq/ir2coq.py
 Source: {src}
 Generated: {ts}
*)
From Coq Require Import Reals.
From Color Require Import Core.
Module Import ColorCore.
"""

FOOTER = """
End ColorCore.
"""

def emit_stmt(stmt: dict, ident: str) -> str:
    kind = stmt.get("kind", "Assumption")
    text = (stmt.get("text") or "").replace("(*", "").replace("*)", "")
    comment = f"(* {kind}: {stmt.get('label','')} *)\n(* Text: {text} *)\n"
    construct = stmt_kind_to_construct(kind)

    if construct == "Axiom":
        return comment + f"Axiom {ident} : Prop.\n\n"
    if construct == "Parameter":
        return comment + f"Parameter {ident} : Prop.\n\n"
    if construct == "Definition":
        # Without a known type/body, emit a Parameter; generator can refine later.
        return comment + f"Parameter {ident} : Prop.\n\n"
    if construct == "Theorem":
        return comment + f"Theorem {ident} : Prop.\nProof.\nAdmitted.\n\n"
    # Fallback
    return comment + f"Parameter {ident} : Prop.\n\n"

def target_module_path(ir: dict) -> str:
    # Base path: coq/Color/Generated/<DocModule>.v
    title = ir.get("document", {}).get("title", "") or ir.get("document", {}).get("id", "Doc")
    seg = sanitize_module_segment(title)
    return f"coq/Color/Generated/{seg}.v"

def render_coq(ir: dict, src: Path) -> str:
    taken = set()
    parts = [HEADER.format(src=src.as_posix(), ts=datetime.now(timezone.utc).isoformat())]
    for st in ir.get("statements", []):
        ident = choose_stmt_ident(st, taken)
        parts.append(emit_stmt(st, ident))
    parts.append(FOOTER)
    return "".join(parts)

def write_text(path: Path, content: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)

def main():
    ap = argparse.ArgumentParser(description="IR â†’ Coq generator")
    ap.add_argument("--ir", default="build/ir", help="Folder with IR JSON files")
    ap.add_argument("--schema", default="docs/ir/ir-schema.json", help="IR schema path")
    args = ap.parse_args()

    ir_dir = Path(args.ir)
    schema_path = Path(args.schema)
    if not ir_dir.exists():
        log(f"[error] IR directory not found: {ir_dir}")
        return 1
    if not schema_path.exists():
        log(f"[error] Schema not found: {schema_path}")
        return 1

    schema = load_schema(schema_path)
    ok_total = 0
    for p in sorted(ir_dir.glob("*.json")):
        try:
            ir = load_ir(p)
            ok, errs = validate_ir(schema, ir)
            if not ok:
                log(f"[error] {p.name}: schema invalid")
                for e in errs[:20]:
                    log("  " + e)
                continue
            out_path = Path(target_module_path(ir))
            content = render_coq(ir, p)
            write_text(out_path, content)
            log(f"[ok] Wrote {out_path}")
            ok_total += 1
        except Exception as e:
            log(f"[error] {p.name}: {e}")
    log(f"Done. Generated {ok_total} Coq modules from IR.")

if __name__ == "__main__":
    raise SystemExit(main())